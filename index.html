<!DOCTYPE html>
<html>
<head>
  <title>Voxel Space Demonstration</title>
  <meta charset="UTF-8">
  <style>
    html, body {margin: 0; height: 100%; overflow: hidden}
    canvas { width: 100%; height: 100%; }
    a { color: white; }

    #fps {
      float: right;
      position: absolute;
      top: 0px;
      right: 10px;
      z-index:100;
      padding: 5px;
      color: black;
      font-family: "Arial", Times, serif;
      font-size: 120%;
      }
  </style>
</head>

<body scroll="no">

<div id="fps">
</div>

<select name="Mapselector" size="1" onchange="LoadMap(this.value);" value="C1W;D1">
<option value="C1W;D1">Map C1W</option>
<option value="C2W;D2">Map C2W</option>
<option value="C3;D3">Map C3</option>
<option value="C4;D4">Map C4</option>
<option value="C5W;D5">Map C5W</option>
<option value="C6W;D6">Map C6W</option>
<option value="C7W;D7">Map C7W</option>
<option value="C8;D6">Map C8</option>
<option value="C9W;D9">Map C9W</option>
<option value="C10W;D10">Map C10W</option>
<option value="C11W;D11">Map C11W</option>
<option value="C12W;D11">Map C12W</option>
<option value="C13;D13">Map C13</option>
<option value="C14;D14">Map C14</option>
<option value="C14W;D14">Map C14W</option>
<option value="C15;D15">Map C15</option>
<option value="C16W;D16">Map C16W</option>
<option value="C17W;D17">Map C17W</option>
<option value="C18W;D18">Map C18W</option>
<option value="C19W;D19">Map C19W</option>
<option value="C20W;D20">Map C20W</option>
<option value="C21;D21">Map C21</option>
<option value="C22W;D22">Map C22W</option>
<option value="C23W;D21">Map C23W</option>
<option value="C24W;D24">Map C24W</option>
<option value="C25W;D25">Map C25W</option>
<option value="C26W;D18">Map C26W</option>
<option value="C27W;D15">Map C27W</option>
<option value="C28W;D25">Map C28W</option>
<option value="C29W;D16">Map C29W</option>
</select>

<label for="distancerange">Distance</label>
<input id="distancerange" type="range" min="100" max="2000" step="1" onchange="camera.distance = this.value;Draw();">
<label for="reliefrange">Relief</label>
<input id="reliefrange" type="range" min="1" max="480" step="1" onchange="camera.relief = this.value;Draw();">

</div>

<canvas id="fullscreenCanvas" width="800" height="400">
  Your browser does not support the canvas element.
</canvas>

<script>
"use strict";

// ---------------------------------------------
// Viewer information

const camera = {
  x:    512, // x position on the map
  y:    800, // y position on the map
  height:  150, // height of the camera
  angle:     0, // direction of the camera
  cos: 1,
  sin: 0,
  horizon:  100, // horizon position (look up and down)
  distance: 800,   // distance of map
  relief: 240,
};

// ---------------------------------------------
// Landscape data

const map = {
  width:  1024,
  height: 1024,
  shift:  10,  // power of two: 2^10 = 1024
  color:  new Uint32Array(1024*1024) // 1024 * 1024 int array with RGB colors and altitude in the high byte
};

// ---------------------------------------------
// Screen data

const screendata = {
  canvas:  null,
  context:   null,
  imagedata: null,

  bufarray:  null, // color data
  buf8:    null, // the same array but with bytes
  buf32:   null, // the same array but with 32-Bit words

  backgroundcolor: 0xFFFFFFFF
};

// ---------------------------------------------
// Keyboard and mouse interaction

const input = {
  forwardbackward: 0,
  leftright:     0,
  updown:      0,
  lookup:      false,
  lookdown:    false,
  mouseposition:   null,
  keypressed:    false
}

let updaterunning = false;

let time = new Date().getTime();

// for fps display
let timelastframe = new Date().getTime();
let frames = 0;

// Update the camera for next frame. Dependent on keypresses
function UpdateCamera() {
  const current = new Date().getTime();

  input.keypressed = false;
  if (input.leftright != 0) {
    camera.angle += input.leftright*0.1*(current-time)*0.03;
    camera.sin = Math.sin(camera.angle);
    camera.cos = Math.cos(camera.angle);
    input.keypressed = true;
  }
  if (input.forwardbackward != 0) {
    camera.x -= input.forwardbackward * Math.sin(camera.angle) * (current-time)*0.03;
    camera.y -= input.forwardbackward * Math.cos(camera.angle) * (current-time)*0.03;
    input.keypressed = true;
  }
  if (input.updown != 0) {
    camera.height += input.updown * (current-time)*0.03;
    input.keypressed = true;
  }
  if (input.lookup) {
    camera.horizon += 2 * (current-time)*0.03;
    input.keypressed = true;
  }
  if (input.lookdown) {
    camera.horizon -= 2 * (current-time)*0.03;
    input.keypressed = true;
  }

  // Collision detection. Don't fly below the surface.
  const mapoffset = ((camera.y & (map.width-1)) << map.shift) + (camera.x & (map.height-1));
  const height = (map.color[mapoffset]>>24)+10;
  if (height > camera.height) camera.height = height;

  time = current;
}

// ---------------------------------------------
// Keyboard and mouse event handlers

function GetMousePosition(e) {
  // fix for Chrome
  if (e.type.startsWith('touch')){
    return [e.targetTouches[0].pageX, e.targetTouches[0].pageY];
  } else {
    return [e.pageX, e.pageY];
  }
}


function DetectMouseDown(e) {
  input.forwardbackward = 3.;
  input.mouseposition = GetMousePosition(e);
  time = new Date().getTime();

  if (!updaterunning) Draw();
  return;
}

function DetectMouseUp() {
  input.mouseposition = null;
  input.forwardbackward = 0;
  input.leftright = 0;
  input.updown = 0;
  return;
}

function DetectMouseMove(e) {
  e.preventDefault();
  if (input.mouseposition == null) return;
  if (input.forwardbackward == 0) return;

  const currentMousePosition = GetMousePosition(e);

  input.leftright = (input.mouseposition[0] - currentMousePosition[0]) / window.innerWidth * 2;
  camera.horizon  = 100 + (input.mouseposition[1] - currentMousePosition[1]) / window.innerHeight * 500;
  input.updown  = (input.mouseposition[1] - currentMousePosition[1]) / window.innerHeight * 10;
}


function DetectKeysDown(e) {
  switch(e.keyCode) {
  case 37:  // left cursor
  case 65:  // a
    input.leftright = +1.;
    break;
  case 39:  // right cursor
  case 68:  // d
    input.leftright = -1.;
    break;
  case 38:  // cursor up
  case 87:  // w
    input.forwardbackward = 3.;
    break;
  case 40:  // cursor down
  case 83:  // s
    input.forwardbackward = -3.;
    break;
  case 82:  // r
    input.updown = +2.;
    break;
  case 70:  // f
    input.updown = -2.;
    break;
  case 69:  // e
    input.lookup = true;
    break;
  case 81:  //q
    input.lookdown = true;
    break;
  default:
    return;
    break;
  }

  if (!updaterunning) {
    time = new Date().getTime();
    Draw();
  }
  return false;
}

function DetectKeysUp(e) {
  switch(e.keyCode) {
  case 37:  // left cursor
  case 65:  // a
    input.leftright = 0;
    break;
  case 39:  // right cursor
  case 68:  // d
    input.leftright = 0;
    break;
  case 38:  // cursor up
  case 87:  // w
    input.forwardbackward = 0;
    break;
  case 40:  // cursor down
  case 83:  // s
    input.forwardbackward = 0;
    break;
  case 82:  // r
    input.updown = 0;
    break;
  case 70:  // f
    input.updown = 0;
    break;
  case 69:  // e
    input.lookup = false;
    break;
  case 81:  //q
    input.lookdown = false;
    break;
  default:
    return;
    break;
  }
  return false;
}

function blend(c1, c2, r) {
  const s = 1 - r;
  return 0xff000000 | (
         (((((c1>>>16)&0xff)*s) << 16)|((((c1>>>8)&0xff)*s) << 8)|((c1&0xff)*s)) +
         (((((c2>>>16)&0xff)*r) << 16)|((((c2>>>8)&0xff)*r) << 8)|((c2&0xff)*r))
  );
}

// ---------------------------------------------
// The main render routine

function Render(screendata, camera, map) {
  const { color, shift } = map;
  const { sin, cos, distance, relief, height, horizon, x, y } = camera;

  const { width: screenwidth, height: screenheight } = screendata.canvas;
  const { buf32, backgroundcolor } = screendata;

  const mapwidthperiod = map.width - 1;
  const mapheightperiod = map.height - 1;

  // 90 degree field of view
  let dx = -cos - sin;
  let dy = sin - cos;
  const d2x =  2 * cos / screenwidth;
  const d2y = -2 * sin / screenwidth;
  const d2 = distance * distance;

  for(let i=0; i<screenwidth; i++) {
    const dr = Math.hypot(dx, dy);
    let pr = dr;
    let px = x;
    let py = y;
    let hiddeny = screenheight;

    for(let z = 1; pr < distance; z++) {
      pr += dr;
      px += dx;
      py += dy;

      // Extract color and height, and calculate the top pixel position for the column
      const c = color[((py & mapwidthperiod) << shift) + (px & mapheightperiod)];
      const ytop = ((height - (c >>> 24)) * relief / z + horizon)|0; // |0 is equivalent to Math.floor

      if (ytop >= hiddeny) continue; // this column is fully occluded

      // get offset on screen for the vertical line
      let offset = ytop * screenwidth + i;

      // calculate final color, with distance fade
      const m = blend(c, backgroundcolor, pr*pr/d2);

      do {
        buf32[offset] = m;
        offset += screenwidth;
      } while (--hiddeny > ytop);
    }

    dx += d2x;
    dy += d2y;
  }
}

// ---------------------------------------------
// Draw the next frame

function Draw() {
  updaterunning = true;
  UpdateCamera();
  // clear background
  screendata.buf32.fill(screendata.backgroundcolor);
  Render(screendata, camera, map);
  // Show the back buffer on screen
  screendata.imagedata.data.set(screendata.buf8);
  screendata.context.putImageData(screendata.imagedata, 0, 0);
  frames++;

  if (!input.keypressed) {
    updaterunning = false;
  } else {
    window.requestAnimationFrame(Draw, 0);
  }
}

// ---------------------------------------------
// Init routines

// Util class for downloading the png
function DownloadImagesAsync(...urls) {
  const tempcanvas = document.createElement("canvas");
  const tempcontext = tempcanvas.getContext("2d");
  return Promise.all(urls.map(url => new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => {
      tempcanvas.width = map.width;
      tempcanvas.height = map.height;
      tempcontext.drawImage(image, 0, 0, map.width, map.height);
      resolve(tempcontext.getImageData(0, 0, map.width, map.height).data);
    };
    image.src = url;
  })));
}

function LoadMap(filenames) {
  const [c, h] = filenames.split(";");
  DownloadImagesAsync(`maps/${c}.png`, `maps/${h}.png`).then(OnLoadedImages);
}

function OnLoadedImages([ datac, datah ]) {
  const size = map.width*map.height;
  for (let i=0,j=0; i<size; i++, j+=4) {
    map.color[i] = (datah[j] << 24) | (datac[j + 2] << 16) | (datac[j + 1] << 8) | datac[j];
  }
  Draw();
}

function OnResizeWindow() {
  const aspect = window.innerWidth / window.innerHeight;

  screendata.canvas.width = window.innerWidth<800?window.innerWidth:800;
  screendata.canvas.height = screendata.canvas.width / aspect;

  if (screendata.canvas.getContext) {
    screendata.context = screendata.canvas.getContext('2d');
    screendata.imagedata = screendata.context.createImageData(screendata.canvas.width, screendata.canvas.height);
  }

  screendata.bufarray = new ArrayBuffer(screendata.imagedata.width * screendata.imagedata.height * 4);
  screendata.buf8   = new Uint8Array(screendata.bufarray);
  screendata.buf32  = new Uint32Array(screendata.bufarray);
  Draw();
}

function Init() {
  screendata.canvas = document.getElementById('fullscreenCanvas');
  map.color.fill(0x00007050);

  LoadMap("C1W;D1");
  OnResizeWindow();

  // set event handlers for keyboard, mouse, touchscreen and window resize
  window.onkeydown  = DetectKeysDown;
  window.onkeyup    = DetectKeysUp;
  window.onmousedown  = DetectMouseDown;
  window.onmouseup  = DetectMouseUp;
  window.onmousemove  = DetectMouseMove;
  window.ontouchstart = DetectMouseDown;
  window.ontouchend   = DetectMouseUp;
  window.ontouchmove  = DetectMouseMove;

  window.onresize     = OnResizeWindow;

  window.setInterval(() => {
    const current = new Date().getTime();
    document.getElementById('fps').innerText = (frames / (current-timelastframe) * 1000).toFixed(1) + " fps";
    frames = 0;
    timelastframe = current;
  }, 100);
}

Init();

</script>
</body>
</html>